<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Currently, there are five STAC documents defined in STAC spec:
STACCatalog
STACCollection
STACCollectionList
STACItem
STACItemCollection


Each document class is associated with STAC API endpoints.
As soon as new STAC documents are proposed in the specification, new
classes can be created in the rstac package.
Let version parameter NULL to detect version automatically.
Basically, there are two types of extensions in STAC specification:
STAC documents extensions: these extensions can be defined in
different elements of the document specification.
STAC API extensions: these extensions are associated with the
interaction between the client and server through API and may add new
elements in the STAC documents or just filter the elements to be returned
in the documents.
Here, we will focus on the second type of extension.
To let rstac package perform some behavior according to an
STAC API extension we need define some functions. These functions
can be implemented in three environments:
In rstac package by including new functions make a
GitHub pull request on rstac repository
(https://github.com/brazil-data-cube/rstac)
In a new package by using rstac as dependent package
In a script that loads rstac into the environment
All these places may impose specific requirements, however the core
logic to implement an extension is the same.
These functions are intended for those who want to implement new STAC API
extensions. An extension must define a subclass name and implement all the
following S3 generic methods for that subclass:
endpoint(): returns the endpoint value of the extension.
Endpoints that vary between STAC API versions can be properly returned by
checking the version field of RSTACQuery object.
before_request(): allows handling query parameters before
submit them to the HTTP server;
after_request(): allows to check and parse document received
by the HTTP server;


These methods will work 'behind the scenes' when a RSTACQuery object
representing a user query are passed to a request function
(e.g. get_request() or post_request()). The calling order is:
begin of get_request() or post_request()
if STAC API version is not defined, try detect it
call endpoint()
call before_request()
send HTTP request
receive HTTP response
after_response()
end of get_request() or post_request()


Besides that, the extension must expose a function to receive user
parameters and return a RSTACQuery object with a subclass
associated with the above S3 methods. This function must accept as its
first parameter a RSTACQuery object representing the actual query.
To keep the command flow consistency, the function needs to check the
subclass of the input query. After that, it must set new or changes the
input query parameters according to the user input and, finally,
return the new query as a RSTACQuery object.
You can see examples on how to implement an STAC API extension by looking at
stac.R, collections.R, items.R, stac_search.R,
and ext_query.R source files. These files implement core STAC API
endpoints, as well as the query API extension.
There are also some utility functions described in Functions
section bellow that can help the extension development."><title>Extension development functions — extensions • rstac</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><link href="../deps/IBM_Plex_Serif-0.4.4/font.css" rel="stylesheet"><link href="../deps/IBM_Plex_Mono-0.4.4/font.css" rel="stylesheet"><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Extension development functions — extensions"><meta property="og:description" content="Currently, there are five STAC documents defined in STAC spec:
STACCatalog
STACCollection
STACCollectionList
STACItem
STACItemCollection


Each document class is associated with STAC API endpoints.
As soon as new STAC documents are proposed in the specification, new
classes can be created in the rstac package.
Let version parameter NULL to detect version automatically.
Basically, there are two types of extensions in STAC specification:
STAC documents extensions: these extensions can be defined in
different elements of the document specification.
STAC API extensions: these extensions are associated with the
interaction between the client and server through API and may add new
elements in the STAC documents or just filter the elements to be returned
in the documents.
Here, we will focus on the second type of extension.
To let rstac package perform some behavior according to an
STAC API extension we need define some functions. These functions
can be implemented in three environments:
In rstac package by including new functions make a
GitHub pull request on rstac repository
(https://github.com/brazil-data-cube/rstac)
In a new package by using rstac as dependent package
In a script that loads rstac into the environment
All these places may impose specific requirements, however the core
logic to implement an extension is the same.
These functions are intended for those who want to implement new STAC API
extensions. An extension must define a subclass name and implement all the
following S3 generic methods for that subclass:
endpoint(): returns the endpoint value of the extension.
Endpoints that vary between STAC API versions can be properly returned by
checking the version field of RSTACQuery object.
before_request(): allows handling query parameters before
submit them to the HTTP server;
after_request(): allows to check and parse document received
by the HTTP server;


These methods will work 'behind the scenes' when a RSTACQuery object
representing a user query are passed to a request function
(e.g. get_request() or post_request()). The calling order is:
begin of get_request() or post_request()
if STAC API version is not defined, try detect it
call endpoint()
call before_request()
send HTTP request
receive HTTP response
after_response()
end of get_request() or post_request()


Besides that, the extension must expose a function to receive user
parameters and return a RSTACQuery object with a subclass
associated with the above S3 methods. This function must accept as its
first parameter a RSTACQuery object representing the actual query.
To keep the command flow consistency, the function needs to check the
subclass of the input query. After that, it must set new or changes the
input query parameters according to the user input and, finally,
return the new query as a RSTACQuery object.
You can see examples on how to implement an STAC API extension by looking at
stac.R, collections.R, items.R, stac_search.R,
and ext_query.R source files. These files implement core STAC API
endpoints, as well as the query API extension.
There are also some utility functions described in Functions
section bellow that can help the extension development."><meta property="og:image" content="/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">rstac</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.9.2-1</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/rstac-01-intro.html">Introduction to rstac package</a>
    <a class="dropdown-item" href="../articles/rstac-02-cql2.html">CQL2 examples</a>
    <a class="dropdown-item" href="../articles/rstac-03-cql2-mpc.html">Reading Planetary Computer Data using CQL2 filter extension</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/brazil-data-cube/rstac/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Extension development functions</h1>
      <small class="dont-index">Source: <a href="https://github.com/brazil-data-cube/rstac/blob/HEAD/R/extensions.R" class="external-link"><code>R/extensions.R</code></a>, <a href="https://github.com/brazil-data-cube/rstac/blob/HEAD/R/query-funs.R" class="external-link"><code>R/query-funs.R</code></a></small>
      <div class="d-none name"><code>extensions.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Currently, there are five STAC documents defined in STAC spec:</p><ul><li><p><code>STACCatalog</code></p></li>
<li><p><code>STACCollection</code></p></li>
<li><p><code>STACCollectionList</code></p></li>
<li><p><code>STACItem</code></p></li>
<li><p><code>STACItemCollection</code></p></li>
</ul><p>Each document class is associated with STAC API endpoints.
As soon as new STAC documents are proposed in the specification, new
classes can be created in the <code>rstac</code> package.</p>
<p>Let <code>version</code> parameter <code>NULL</code> to detect version automatically.</p>
<p>Basically, there are two types of extensions in STAC specification:</p><ol><li><p>STAC documents extensions: these extensions can be defined in
different elements of the document specification.</p></li>
<li><p>STAC API extensions: these extensions are associated with the
interaction between the client and server through API and may add new
elements in the STAC documents or just filter the elements to be returned
in the documents.</p></li>
</ol><p>Here, we will focus on the second type of extension.</p>
<p>To let <code>rstac</code> package perform some behavior according to an
STAC API extension we need define some functions. These functions
can be implemented in three environments:</p><ol><li><p>In <code>rstac</code> package by including new functions make a
GitHub pull request on <code>rstac</code> repository
(<a href="https://github.com/brazil-data-cube/rstac" class="external-link">https://github.com/brazil-data-cube/rstac</a>)</p></li>
<li><p>In a new package by using <code>rstac</code> as dependent package</p></li>
<li><p>In a script that loads <code>rstac</code> into the environment</p></li>
</ol><p>All these places may impose specific requirements, however the core
logic to implement an extension is the same.</p>
<p>These functions are intended for those who want to implement new STAC API
extensions. An extension must define a subclass name and implement all the
following S3 generic methods for that subclass:</p><ul><li><p><code>endpoint()</code>: returns the endpoint value of the extension.
Endpoints that vary between STAC API versions can be properly returned by
checking the <code>version</code> field of <code>RSTACQuery</code> object.</p></li>
<li><p><code>before_request()</code>: allows handling query parameters before
submit them to the HTTP server;</p></li>
<li><p><code>after_request()</code>: allows to check and parse document received
by the HTTP server;</p></li>
</ul><p>These methods will work 'behind the scenes' when a <code>RSTACQuery</code> object
representing a user query are passed to a request function
(e.g. <code><a href="request.html">get_request()</a></code> or <code><a href="request.html">post_request()</a></code>). The calling order is:</p><ol><li><p>begin of <code><a href="request.html">get_request()</a></code> or <code><a href="request.html">post_request()</a></code></p></li>
<li><p>if STAC API version is not defined, try detect it</p></li>
<li><p>call <code>endpoint()</code></p></li>
<li><p>call <code>before_request()</code></p></li>
<li><p>send HTTP request</p></li>
<li><p>receive HTTP response</p></li>
<li><p><code>after_response()</code></p></li>
<li><p>end of <code><a href="request.html">get_request()</a></code> or <code><a href="request.html">post_request()</a></code></p></li>
</ol><p>Besides that, the extension must expose a function to receive user
parameters and return a <code>RSTACQuery</code> object with a subclass
associated with the above S3 methods. This function must accept as its
first parameter a <code>RSTACQuery</code> object representing the actual query.
To keep the command flow consistency, the function needs to check the
subclass of the input query. After that, it must set new or changes the
input query parameters according to the user input and, finally,
return the new query as a <code>RSTACQuery</code> object.</p>
<p>You can see examples on how to implement an STAC API extension by looking at
<code>stac.R</code>, <code>collections.R</code>, <code>items.R</code>, <code>stac_search.R</code>,
and <code>ext_query.R</code> source files. These files implement core STAC API
endpoints, as well as the query API extension.</p>
<p>There are also some utility functions described in <strong>Functions</strong>
section bellow that can help the extension development.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">endpoint</span><span class="op">(</span><span class="va">q</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">before_request</span><span class="op">(</span><span class="va">q</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">after_response</span><span class="op">(</span><span class="va">q</span>, <span class="va">res</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">parse_params</span><span class="op">(</span><span class="va">q</span>, <span class="va">params</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">content_response</span><span class="op">(</span></span>
<span>  <span class="va">res</span>,</span>
<span>  <span class="va">status_codes</span>,</span>
<span>  <span class="va">content_types</span>,</span>
<span>  key_message <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"message"</span>, <span class="st">"description"</span>, <span class="st">"detail"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">check_query_verb</span><span class="op">(</span><span class="va">q</span>, <span class="va">verbs</span>, msg <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">check_subclass</span><span class="op">(</span><span class="va">x</span>, <span class="va">subclasses</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">subclass</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">omit_query_params</span><span class="op">(</span><span class="va">q</span>, <span class="va">names</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">RSTACQuery</span><span class="op">(</span>version <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">base_url</span>, params <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">subclass</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>q</dt>
<dd><p>a <code>RSTACQuery</code> object.</p></dd>


<dt>res</dt>
<dd><p>a <code>httr</code> <code>response</code> object.</p></dd>


<dt>params</dt>
<dd><p>a named <code>list</code> with all URL query parameters to be
appended in the URL.</p></dd>


<dt>status_codes</dt>
<dd><p>a <code>character</code> vector with successful
status codes.</p></dd>


<dt>content_types</dt>
<dd><p>a <code>character</code> vector with all acceptable
responses' content type.</p></dd>


<dt>key_message</dt>
<dd><p>a <code>character</code> vector with the JSON keys to show the
requested API message.</p></dd>


<dt>verbs</dt>
<dd><p>a <code>character</code> vector with allowed HTTP request methods</p></dd>


<dt>msg</dt>
<dd><p>a <code>character</code> with a personalized error message</p></dd>


<dt>x</dt>
<dd><p>either a <code>RSTACQuery</code> object expressing a STAC query
criteria or any <code>RSTACDocument</code>.</p></dd>


<dt>subclasses</dt>
<dd><p>a <code>character</code> vector with all allowed S3 subclasses</p></dd>


<dt>names</dt>
<dd><p>a <code>character</code> vector with the names do omit.</p></dd>


<dt>version</dt>
<dd><p>a <code>character</code> with the STAC version.</p></dd>


<dt>base_url</dt>
<dd><p>a <code>character</code> informing the base URL of a
STAC web service.</p></dd>


<dt>subclass</dt>
<dd><p>a <code>character</code> corresponding to the subclass of the
object to be created.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>A <code>character</code> endpoint value for <code>endpoint()</code> function.
A <code>RSTACQuery</code> object for <code>before_request()</code> and
<code>after_response()</code> functions.</p>


<p>The <code>content_response()</code> function returns a <code>list</code> data structure
representing the JSON file received in HTTP response</p>


<p>The <code>RSTACQuery()</code> function returns a <code>STACQuery</code> object with
subclass defined by <code>subclass</code> parameter.</p>
    </div>
    <div class="section level2">
    <h2 id="functions">Functions<a class="anchor" aria-label="anchor" href="#functions"></a></h2>
    
<ul><li><p><code>content_response()</code>: The <code>content_response</code> function checks if the request's
response is in accordance with the allowed status codes and content-types.
It returns the parsed content response.</p></li>
<li><p><code>check_query_verb()</code>: The <code>check_query_verb()</code> function allows you to define which HTTP
verbs are allowed. It is useful for establishing which verbs will be
supported by an extension.</p></li>
<li><p><code>check_subclass()</code>: The <code>check_subclass()</code> function specifies which type of query
objects (<code>RSTACQuery</code>) or document objects (<code>RSTACDocument</code>)
are expected in the function extension.</p></li>
<li><p><code>subclass()</code>: The <code>subclass()</code> function returns a <code>character</code> representing the
subclass name of either <code>RSTACQuery</code> or <code>RSTACDocument</code> S3 classes.</p></li>
<li><p><code>omit_query_params()</code>: The <code>omit_query_params()</code> function was created to omit the paths that
are defined as query parameters to simplify the creation of a query.
Therefore, use this method only in endpoints that specify a parameter in
their paths.</p></li>
<li><p><code>RSTACQuery()</code>: The <code>RSTACQuery()</code> function is a constructor of <code>RSTACQuery</code>
objects. Every extension must implement a subclass of <code>RSTACQuery</code> to
represent its queries. This is done by informing to the <code>subclass</code>
parameter the extension's subclass name.</p>
<p>The <code>params</code> parameter is a named <code>list</code> where user parameters
must be stored. It is important to know if previous query parameters needs
to be keeped in the new query. If so, it is recommended do use
<code><a href="https://rdrr.io/r/utils/modifyList.html" class="external-link">utils::modifyList()</a></code> function to merge the old and new
query parameters.</p>
<p>If the <code>version</code> parameter is <code>NULL</code>, <code>rstac</code> will detect
STAC API version automatically.</p>
<p>In general, if you are implementing a new subclass, the parameters
<code>version</code> and <code>url</code> will be the same as the previous query. The
<code>params</code> parameter will be merged with previous query. And subclass
is the extension's subclass name.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="ext_query.html">ext_query()</a></code></p></div>
    </div>

  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Rolf Simoes, Felipe Carvalho, Brazil Data Cube Team.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

